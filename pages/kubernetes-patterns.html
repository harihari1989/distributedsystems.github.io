<!doctype html>
<html lang="en" data-color-mode="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Kubernetes Patterns | Distributed Systems Visual Guide</title>
    <link rel="stylesheet" href="../assets/css/theme.css" />
    <script defer src="../assets/js/toggleTheme.js"></script>
    <script defer src="../assets/js/site.js"></script>
    <script defer src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script defer src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script defer src="../assets/js/playgrounds.js"></script>
    <script defer src="../assets/js/k8s-explorer.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script defer src="../assets/js/mermaid-init.js"></script>
  </head>
  <body>
    <header class="site-header">
      <div class="site-brand">
        <a href="../index.html">Distributed Systems Visual Guide</a>
      </div>
      <nav class="site-nav">
        <a href="../index.html">Home</a>
        <a href="compute-patterns.html">Compute</a>
        <a href="database-architectures.html">Storage</a>
        <a href="database-patterns.html">Databases</a>
        <a href="consistency-models.html">Consistency</a>
        <a href="networking-patterns.html">Networking</a>
        <a href="kubernetes-patterns.html" class="is-active" aria-current="page">Kubernetes</a>
        <a href="operating-systems.html">Operating Systems</a>
      </nav>
      <button class="theme-toggle" type="button" onclick="toggleColorMode()">Toggle theme</button>
    </header>
    <main>
      <h1>Kubernetes Patterns</h1>

      <section id="k8s-explorer">
        <h2>Visual Kubernetes Architecture Explorer</h2>
        <p>
          Stop memorizing Kubernetes. Watch it think.
          This explorer turns controllers, state reconciliation, and network flows into animated systems you can pause, step, and probe.
        </p>
        <div id="k8s-explorer-root"></div>
      </section>

      <section>
        <h2>Problem framing</h2>
        <p>
          Modern distributed systems need repeatable deployment, scaling, and recovery without bespoke automation per service.
          Kubernetes abstracts the infrastructure layer so teams can standardize scheduling, rollout, and service discovery.
          Patterns emerge to make those primitives safe at scale and to avoid fragile, ad hoc operational playbooks.
        </p>
      </section>

      <section>
        <h2>Core idea / pattern</h2>
        <h3>Pods, services, and ingress</h3>
        <p>
          Pods are the smallest schedulable unit and encapsulate one or more tightly coupled containers.
          Services provide stable virtual IPs and discovery for ephemeral pods.
          Ingress exposes services externally and centralizes TLS termination and routing.
        </p>

        <table>
          <thead>
            <tr>
              <th>Component</th>
              <th>Role</th>
              <th>Strengths</th>
              <th>Risks</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Pod</td>
              <td>Co-scheduled containers with shared network</td>
              <td>Tight coupling, shared volumes</td>
              <td>Coupled failure domain</td>
            </tr>
            <tr>
              <td>Service</td>
              <td>Stable name + load balancing</td>
              <td>Decouples clients from pods</td>
              <td>Misconfigured selectors cause blackholes</td>
            </tr>
            <tr>
              <td>Ingress</td>
              <td>External routing and TLS</td>
              <td>Centralized policy</td>
              <td>Single critical layer if unscaled</td>
            </tr>
          </tbody>
        </table>

        <h3>Sidecar pattern</h3>
        <p>
          Sidecars add cross-cutting concerns such as mTLS, logging, or rate limiting without changing app code.
          This pattern enables consistent policy but increases resource usage and operational complexity.
          See <a href="networking-patterns.html">networking patterns</a> for gateway and mesh details.
        </p>

        <h3>Operators and controllers</h3>
        <p>
          Controllers reconcile desired state to actual state, making systems self-healing.
          Operators extend this with domain-specific automation such as backups or failover.
          The reconciliation loop is the core reliability mechanic, not an optional detail.
        </p>

        <h3>Autoscaling</h3>
        <p>
          Horizontal Pod Autoscaler (HPA) scales replica counts based on metrics like CPU or custom signals.
          Vertical Pod Autoscaler (VPA) adjusts resource requests and limits to fit observed usage.
          Autoscaling depends on accurate metrics and sane limits to avoid oscillation.
        </p>
      </section>

      <section>
        <h2>Architecture diagram</h2>
        <pre class="mermaid">
flowchart LR
  Client[Client] --> Ingress[Ingress]
  Ingress --> Svc[Service]
  Svc --> PodA[Pod A]
  Svc --> PodB[Pod B]
  PodA --> SidecarA[Sidecar]
  PodB --> SidecarB[Sidecar]
  Controller[Controller] --> Deploy[Deployment]
  Deploy --> PodA
  Deploy --> PodB
        </pre>
      </section>

      <section>
        <h2>Animated flow</h2>
        <div class="viz">
          <svg viewBox="0 0 820 240" role="img" aria-label="Animated Kubernetes flow from ingress to services and pods.">
            <rect class="node pulse" x="30" y="90" width="120" height="60" rx="14"></rect>
            <text x="54" y="125">Ingress</text>

            <rect class="node" x="200" y="90" width="120" height="60" rx="14"></rect>
            <text x="224" y="125">Service</text>

            <rect class="node pulse" x="380" y="40" width="140" height="60" rx="14"></rect>
            <text x="410" y="75">Pod A</text>

            <rect class="node pulse-slow" x="380" y="130" width="140" height="60" rx="14"></rect>
            <text x="410" y="165">Pod B</text>

            <rect class="node" x="580" y="40" width="180" height="60" rx="14"></rect>
            <text x="610" y="75">Sidecar</text>

            <rect class="node" x="580" y="130" width="180" height="60" rx="14"></rect>
            <text x="610" y="165">Sidecar</text>

            <path class="edge flow" d="M150 120 L200 120"></path>
            <path class="edge flow" d="M320 120 L380 70"></path>
            <path class="edge flow" d="M320 120 L380 160"></path>
            <path class="edge flow" d="M520 70 L580 70"></path>
            <path class="edge flow" d="M520 160 L580 160"></path>

            <circle class="packet" r="4">
              <animateMotion dur="3.8s" repeatCount="indefinite" path="M150 120 L200 120 L380 70 L580 70"></animateMotion>
            </circle>
            <circle class="packet" r="4">
              <animateMotion dur="4.4s" begin="1s" repeatCount="indefinite" path="M150 120 L200 120 L380 160 L580 160"></animateMotion>
            </circle>
          </svg>
        </div>
      </section>

      <section>
        <h2>Step-by-step flow</h2>
        <ol>
          <li>A client connects to the ingress endpoint over TLS.</li>
          <li>Ingress routes the request to a service based on hostname and path.</li>
          <li>The service load balances across healthy pod endpoints.</li>
          <li>The sidecar enforces mTLS or policy before the app container handles the request.</li>
          <li>Controllers observe desired state and replace unhealthy pods automatically.</li>
        </ol>
      </section>

      <section>
        <h2 id="playground-hpa">Playground: Autoscaling response</h2>
        <div id="playground-hpa-root"></div>
      </section>

      <section>
        <h2>Failure modes</h2>
        <ul>
          <li>Misconfigured readiness probes route traffic to unhealthy pods.</li>
          <li>Ingress or service selectors drift from labels, causing traffic drops.</li>
          <li>Sidecars crash-loop and block app traffic, creating partial outages.</li>
          <li>HPA scales on noisy metrics and causes oscillation or thundering herds.</li>
          <li>Resource limits are too low, leading to OOM kills and instability.</li>
        </ul>
      </section>

      <section>
        <h2>Trade-offs</h2>
        <ul>
          <li>Kubernetes reduces manual ops but increases platform complexity and learning cost.</li>
          <li>Sidecars centralize policy but add CPU and memory overhead.</li>
          <li>Operators automate complex workflows but can hide critical domain assumptions.</li>
          <li>HPA improves responsiveness but can amplify load spikes without backpressure.</li>
          <li>Ingress centralizes routing but can become a bottleneck if underprovisioned.</li>
        </ul>
      </section>

      <section>
        <h2>Real-world usage</h2>
        <ul>
          <li>Production clusters commonly use NGINX or Envoy-based ingress controllers.</li>
          <li>Service meshes such as Istio or Linkerd deploy sidecars for mTLS and routing.</li>
          <li>Operators manage databases like PostgreSQL or Kafka with custom failover logic.</li>
          <li>Autoscaling pairs HPA with cluster autoscalers to add nodes as load grows.</li>
        </ul>
      </section>
    </main>
    <footer class="site-footer">
      <div>Built for senior engineers and system designers.</div>
      <div>Distributed Systems Visual Guide.</div>
    </footer>
  </body>
</html>
