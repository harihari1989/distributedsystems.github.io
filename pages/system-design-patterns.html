<!doctype html>
<html lang="en" data-color-mode="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>System Design Interview Patterns | Distributed Systems Visual Guide</title>
    <link rel="stylesheet" href="../assets/css/theme.css" />
    <script defer src="../assets/js/toggleTheme.js"></script>
    <script defer src="../assets/js/site.js"></script>
    <script defer src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script defer src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script defer src="../assets/js/playgrounds.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script defer src="../assets/js/mermaid-init.js"></script>
  </head>
  <body>
    <header class="site-header">
      <div class="site-brand">
        <a href="../index.html">Distributed Systems Visual Guide</a>
      </div>
      <nav class="site-nav">
        <a href="../index.html">Home</a>
        <a href="compute-patterns.html">Compute</a>
        <a href="database-architectures.html">Storage</a>
        <a href="consistency-models.html">Consistency</a>
        <a href="networking-patterns.html">Networking</a>
        <a href="kubernetes-patterns.html">Kubernetes</a>
        <a href="system-design-patterns.html" class="is-active" aria-current="page">Interview</a>
      </nav>
      <button class="theme-toggle" type="button" onclick="toggleColorMode()">Toggle theme</button>
    </header>
    <main>
      <h1>System Design Interview Patterns</h1>

      <section>
        <h2>Why this problem exists</h2>
        <p>
          System design interviews test whether you can identify core failure modes and apply proven patterns.
          These patterns recur because they address coordination, reliability, and scaling constraints that appear in most systems.
          Knowing when to apply them is as important as knowing how they work.
        </p>
      </section>

      <section>
        <h2>Core idea / pattern</h2>
        <h3>Leader election</h3>
        <p>
          Leader election provides a single authority for coordination tasks like scheduling or primary writes.
          It reduces conflict but introduces leadership failure handling and split-brain risk.
        </p>

        <h3>Quorum reads and writes</h3>
        <p>
          Quorums require a minimum number of replicas to acknowledge reads or writes.
          They balance consistency and availability using R + W &gt; N to ensure overlap.
        </p>

        <h3>Consensus (Raft, Paxos)</h3>
        <p>
          Consensus ensures a set of nodes agree on a sequence of values even under failure.
          Use it for critical metadata or coordination, not as a general data plane for all writes.
        </p>

        <h3>Idempotency</h3>
        <p>
          Idempotency allows retrying requests without unintended side effects.
          It is essential for safe retries in unreliable networks.
        </p>

        <h3>Rate limiting and circuit breakers</h3>
        <p>
          Rate limiting shapes traffic to protect downstream services.
          Circuit breakers fail fast when dependencies are unhealthy to prevent cascading failure.
          See <a href="networking-patterns.html">networking patterns</a> for backpressure context.
        </p>

        <table>
          <thead>
            <tr>
              <th>Pattern</th>
              <th>Primary goal</th>
              <th>Typical risk</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Leader election</td>
              <td>Single authority for coordination</td>
              <td>Split brain, failover delays</td>
            </tr>
            <tr>
              <td>Quorums</td>
              <td>Bounded consistency</td>
              <td>Higher latency and cost</td>
            </tr>
            <tr>
              <td>Consensus</td>
              <td>Agree on ordering</td>
              <td>Complexity, performance overhead</td>
            </tr>
            <tr>
              <td>Idempotency</td>
              <td>Safe retries</td>
              <td>Storage of dedupe keys</td>
            </tr>
            <tr>
              <td>Rate limiting</td>
              <td>Protect dependencies</td>
              <td>Over-throttling users</td>
            </tr>
          </tbody>
        </table>
      </section>

      <section>
        <h2>Architecture diagram</h2>
        <pre class="mermaid">
flowchart LR
  Client[Client] --> API[API Service]
  API --> Limiter[Rate Limiter]
  Limiter --> Queue[Work Queue]
  Queue --> Worker1[Worker A]
  Queue --> Worker2[Worker B]
  Worker1 --> Store[(Primary Store)]
  Worker2 --> Store
  Store --> Replica[(Replica)]
        </pre>
      </section>

      <section>
        <h2>Animated flow</h2>
        <div class="viz">
          <svg viewBox="0 0 900 240" role="img" aria-label="Animated request flow through rate limiter, queue, workers, and storage.">
            <rect class="node pulse" x="20" y="90" width="120" height="60" rx="14"></rect>
            <text x="50" y="125">Client</text>

            <rect class="node" x="170" y="90" width="140" height="60" rx="14"></rect>
            <text x="200" y="125">API</text>

            <rect class="node" x="340" y="90" width="140" height="60" rx="14"></rect>
            <text x="360" y="125">Limiter</text>

            <rect class="node pulse-slow" x="510" y="90" width="120" height="60" rx="14"></rect>
            <text x="540" y="125">Queue</text>

            <rect class="node" x="660" y="40" width="140" height="60" rx="14"></rect>
            <text x="690" y="75">Worker A</text>

            <rect class="node" x="660" y="140" width="140" height="60" rx="14"></rect>
            <text x="690" y="175">Worker B</text>

            <rect class="node pulse" x="750" y="90" width="120" height="60" rx="14"></rect>
            <text x="775" y="125">Store</text>

            <path class="edge flow" d="M140 120 L170 120"></path>
            <path class="edge flow" d="M310 120 L340 120"></path>
            <path class="edge flow" d="M480 120 L510 120"></path>
            <path class="edge flow" d="M630 120 L660 70"></path>
            <path class="edge flow" d="M630 120 L660 170"></path>
            <path class="edge flow" d="M800 70 L750 120"></path>
            <path class="edge flow" d="M800 170 L750 120"></path>

            <circle class="packet" r="4">
              <animateMotion dur="3.8s" repeatCount="indefinite" path="M140 120 L170 120 L340 120 L510 120 L660 70 L750 120"></animateMotion>
            </circle>
            <circle class="packet" r="4">
              <animateMotion dur="4.6s" begin="1s" repeatCount="indefinite" path="M140 120 L170 120 L340 120 L510 120 L660 170 L750 120"></animateMotion>
            </circle>
          </svg>
        </div>
      </section>

      <section>
        <h2>Step-by-step flow</h2>
        <ol>
          <li>The client submits a request with an idempotency key.</li>
          <li>The API service checks the rate limiter and rejects if over quota.</li>
          <li>The request enters a queue to smooth bursts and provide backpressure.</li>
          <li>Workers process the request and write to a replicated store.</li>
          <li>Reads use quorum policies to balance consistency and latency.</li>
        </ol>
      </section>

      <section>
        <h2 id="playground-rate-limits">Playground: Rate limiter behavior</h2>
        <div id="playground-rate-limits-root"></div>
      </section>

      <section>
        <h2>Failure modes</h2>
        <ul>
          <li>Split-brain leaders accept conflicting writes without proper quorum.</li>
          <li>Duplicate processing occurs when retries lack idempotency protection.</li>
          <li>Overly strict rate limits cause self-inflicted denial of service.</li>
          <li>Queues hide saturation and increase latency without clear backpressure signals.</li>
          <li>Consensus paths become a bottleneck when used for all writes.</li>
        </ul>
      </section>

      <section>
        <h2>Trade-offs</h2>
        <ul>
          <li>Leaders simplify coordination but introduce failover complexity and temporary unavailability.</li>
          <li>Quorums improve correctness but increase write latency and cost.</li>
          <li>Idempotency improves reliability but requires storage and lifecycle management for keys.</li>
          <li>Rate limiting protects dependencies but can reduce throughput for bursty workloads.</li>
          <li>Circuit breakers avoid cascading failure but require careful reset and fallback logic.</li>
        </ul>
      </section>

      <section>
        <h2>Real-world usage</h2>
        <ul>
          <li>ZooKeeper, etcd, and Consul provide leader election and consensus.</li>
          <li>Dynamo-style systems use tunable quorums for reads and writes.</li>
          <li>Payment and order processing APIs rely on idempotency keys.</li>
          <li>Gateways enforce rate limits and circuit breakers for shared dependencies.</li>
        </ul>
      </section>

      <section>
        <h2>Interview tips</h2>
        <ul>
          <li>Call out which components require strong coordination versus eventual consistency.</li>
          <li>Explain how retries, idempotency, and rate limits work together.</li>
          <li>Show how you prevent split-brain and handle leader failover.</li>
          <li>Tie quorum sizes to failure domains and SLA requirements.</li>
          <li>Mention how you observe and tune limits in production.</li>
        </ul>
      </section>
    </main>
    <footer class="site-footer">
      <div>Built for senior engineers and system designers.</div>
      <div>Distributed Systems Visual Guide.</div>
    </footer>
  </body>
</html>
